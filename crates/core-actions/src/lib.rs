//! High-level semantic editor actions, key translation, and command dispatch.
//!
//! Scope (Refactor R3):
//! - `Action` enum models motions, edits, mode transitions, command-line lifecycle,
//!   undo/redo, and (scaffolded) operator application variants.
//! - `KeyTranslator` (stateful) replaces earlier stateless free function; currently
//!   semantics are identical while laying groundwork for count & operator-pending
//!   logic (Phase 4 enablement).
//! - Modular dispatcher (split into motion/edit/command/mode/undo submodules) reduces
//!   single-file churn and keeps future feature growth localized.
//! - Command parsing layer isolates `:commands` growth (`:metrics` stub added in Step 11).
//!
//! Design Tenets Applied:
//! - Breadth-first: operator & count variants exist but are not emitted yet.
//! - Modularity: translation, dispatch, IO helpers, and parser separated for clarity.
//! - Evolution over legacy: deprecated stateless translator path shims to the new
//!   stateful version and can be removed once Phase 4 count/operator work lands.
//!
//! Phase 4 Status:
//! - Numeric count prefixes (Step 1) now accumulate into `MotionWithCount` and are
//!   internally expanded by dispatcher logic (preserving one Action per keypress).
//! - Operator-pending + application variants (`BeginOperator`, `ApplyOperator`) are
//!   live; delete/yank/change semantics integrate with register + undo layers.
//! - Motion span resolution (Step 4) centralizes grapheme/word iteration rules so
//!   operator engines and future visual selections share identical span semantics.
//! - Future: register selection, paste, macro recording, and async action hooks.
//!
//! Forward (Phase 5+ Roadmap):
//! - Explicit register selection (`"a`), paste operators, macro record/replay.
//! - Async command execution hooks (LSP formatting, code actions) via observer
//!   extension point.

use core_config::Config;
use core_events::KeyEvent;
use core_state::Mode;
pub mod span_resolver; // Phase 4 Step 4
pub mod text_object; // Refactor R4 Step 15: text object trait stub

#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
/// Pre-Phase 4 operator kind scaffold. Variants are doc-hidden and not yet
/// produced by key translation. Introduced in Refactor R3 Step 4 to enable
/// forward-compatible wiring of operator/count logic without semantic changes.
pub enum OperatorKind {
    Delete,
    Yank,
    Change,
}

/// Observer hook (Refactor R1 Step 8): allows external components (macro recorder, analytics,
/// future plugin host) to observe Actions as they are translated and/or dispatched without
/// mutating editor state. Breadth-first: only pre-dispatch hook provided now.
///
/// Observers MUST be cheap and non-blocking; heavy work should be offloaded asynchronously.
pub trait ActionObserver: Send + Sync {
    /// Called immediately before an Action is dispatched (state not yet mutated).
    fn on_action(&self, action: &Action);
}

impl<T: ActionObserver + ?Sized> ActionObserver for &T {
    fn on_action(&self, action: &Action) {
        (**self).on_action(action)
    }
}

#[derive(Debug, Clone)]
pub enum Action {
    Motion(MotionKind),
    #[doc(hidden)]
    /// Count-prefixed motion (e.g. `5l`). Introduced Phase 4 Step 1. The
    /// translator collapses the numeric prefix and emits a single action
    /// which the dispatcher will iterate internally to preserve the one
    /// key-event => one dispatched action invariant.
    MotionWithCount {
        motion: MotionKind,
        count: u32,
    },
    Edit(EditKind),
    ModeChange(ModeChange),
    Undo,
    Redo,
    /// Paste after cursor (Normal mode 'p'). Optional explicit register prefix.
    PasteAfter {
        register: Option<char>,
    },
    /// Paste before cursor (Normal mode 'P'). Optional explicit register prefix.
    PasteBefore {
        register: Option<char>,
    },
    #[doc(hidden)]
    /// Begin an operator sequence (awaiting a motion). Not yet generated by key
    /// translation (Refactor R3 Step 4 scaffold).
    BeginOperator(OperatorKind),
    #[doc(hidden)]
    /// Apply an operator to a motion with an optional count already resolved.
    /// Not yet generated; future Phase 4 translator logic will emit.
    ApplyOperator {
        op: OperatorKind,
        motion: MotionKind,
        count: u32,
        register: Option<char>,
    },
    #[doc(hidden)]
    /// Apply an operator to an implicit linewise span (double-operator shorthand like `dd`).
    /// The translator resolves any counts and register prefixes before emitting this action.
    LinewiseOperator {
        op: OperatorKind,
        count: u32,
        register: Option<char>,
    },
    /// Apply an operator directly to the current active visual selection (Phase 5 Step 4).
    /// Emitted when pressing d/y/c while in VisualChar mode. The dispatcher will
    /// interpret the current selection span (if non-empty) and perform the operator
    /// semantics, then clear the selection (entering Insert for Change).
    VisualOperator {
        op: OperatorKind,
        register: Option<char>,
    },
    // Command line actions (Task 7.1 Action Enum Refinement)
    CommandStart,           // begin command line (inserts leading ':')
    CommandChar(char),      // insert character into command buffer
    CommandBackspace,       // remove last character or cancel if only ':'
    CommandCancel,          // abort command (Esc)
    CommandExecute(String), // execute full buffer (still includes leading ':')
    Quit,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MotionKind {
    Left,
    Right,
    Up,
    Down,
    LineStart,
    LineEnd,
    WordForward,
    WordBackward,
    /// Half page down (Phase 2 Step 11)
    PageHalfDown,
    /// Half page up (Phase 2 Step 11)
    PageHalfUp,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum EditKind {
    InsertGrapheme(String),
    InsertNewline,
    Backspace,
    DeleteUnder,
    DeleteLeft,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModeChange {
    EnterInsert,
    LeaveInsert,
    EnterVisualChar,
    LeaveVisualChar,
}

/// Public translation API. NGI adapter is now the single translation path.
pub fn translate_key(mode: Mode, pending_command: &str, key: &KeyEvent) -> Option<Action> {
    translate_key_with_config(mode, pending_command, key, &Config::default())
}

pub fn translate_key_with_config(
    mode: Mode,
    pending_command: &str,
    key: &KeyEvent,
    cfg: &Config,
) -> Option<Action> {
    crate::ngi_adapter::translate_ngi(mode, pending_command, key, cfg).action
}

pub mod dispatcher;
pub mod io_ops; // Refactor R2 Step 5: file IO helpers

pub use dispatcher::dispatch; // re-export for test convenience (Phase 5 Visual operators)

// -------------------------------------------------------------------------------------------------
// NGI Adapter: maps key sequences via core-keymap to existing Action enum.
// -------------------------------------------------------------------------------------------------
pub mod ngi_adapter {
    use super::{Action, EditKind, Mode, ModeChange, MotionKind, OperatorKind};
    use core_config::Config; // for timeout settings (passed in future wiring)
    use core_events::{KeyCode, KeyEvent, KeyModifiers};
    use core_keymap::{
        ComposedAction, MappingTrie, PendingContext, baseline_normal_specs, compose_with_context,
    };
    use std::cell::RefCell;
    use std::time::{Duration, Instant};
    use tracing::trace;

    thread_local! {
        static TRIE: MappingTrie = MappingTrie::build(baseline_normal_specs());
        static CTX: RefCell<PendingContext> = RefCell::new(PendingContext::default());
    static BUFFER: RefCell<Vec<char>> = const { RefCell::new(Vec::new()) };
        static PARTIAL_TIMER: RefCell<PartialTimeoutState> = const { RefCell::new(PartialTimeoutState::new()) };
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    enum PartialKind {
        Generic,
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum PendingState {
        Idle,
        AwaitingMore { buffered_len: usize },
    }

    #[derive(Debug, Clone)]
    pub struct NgiResolution {
        pub action: Option<Action>,
        pub pending_state: PendingState,
        pub timeout_deadline: Option<Instant>,
    }

    impl NgiResolution {
        fn new(
            action: Option<Action>,
            pending_state: PendingState,
            timeout_deadline: Option<Instant>,
        ) -> Self {
            Self {
                action,
                pending_state,
                timeout_deadline,
            }
        }
    }

    #[derive(Debug, Default)]
    struct PartialTimeoutState {
        kind: Option<PartialKind>,
        started: Option<Instant>,
    }

    impl PartialTimeoutState {
        const fn new() -> Self {
            Self {
                kind: None,
                started: None,
            }
        }
        fn start(&mut self, kind: PartialKind) {
            if self.kind.is_none() {
                // start only on first ambiguous prefix
                self.kind = Some(kind);
                self.started = Some(Instant::now());
                trace!(target = "actions.translate", kind = "timeout_start");
            }
        }
        fn clear(&mut self) {
            if self.kind.is_some() {
                trace!(target = "actions.translate", kind = "timeout_clear");
            }
            self.kind = None;
            self.started = None;
        }
        fn deadline(&self, cfg: &Config) -> Option<Instant> {
            if !cfg.file.input.timeout {
                return None;
            }
            self.started
                .map(|start| start + Duration::from_millis(cfg.file.input.timeoutlen as u64))
        }
    }

    pub fn translate_ngi(
        mode: Mode,
        pending_command: &str,
        key: &KeyEvent,
        cfg: &Config,
    ) -> NgiResolution {
        // Command-line editing when ':' is active (pending buffer starts with ':').
        // Handle this early to avoid feeding command characters into the trie.
        if pending_command.starts_with(':') {
            let action = match key.code {
                KeyCode::Char(c)
                    if !key.mods.contains(KeyModifiers::CTRL)
                        && !key.mods.contains(KeyModifiers::ALT) =>
                {
                    trace!(target = "actions.translate", kind = "command_char");
                    Some(Action::CommandChar(c))
                }
                KeyCode::Enter => {
                    // Do not log full command text; keep noise disciplined (logging.md).
                    trace!(
                        target = "actions.translate",
                        kind = "command_execute",
                        len = pending_command.len()
                    );
                    Some(Action::CommandExecute(pending_command.to_string()))
                }
                KeyCode::Backspace => {
                    trace!(target = "actions.translate", kind = "command_backspace");
                    Some(Action::CommandBackspace)
                }
                KeyCode::Esc => {
                    trace!(target = "actions.translate", kind = "command_cancel");
                    Some(Action::CommandCancel)
                }
                _ => None,
            };
            return finalize_resolution(action, cfg);
        }
        // VisualChar: motions apply to selection; d/y/c operate on selection; 'v' toggles exit.
        if matches!(mode, Mode::VisualChar) {
            let action = match key.code {
                KeyCode::Esc => {
                    trace!(target = "actions.translate", kind = "leave_visual_char");
                    Some(Action::ModeChange(ModeChange::LeaveVisualChar))
                }
                // Half-page motions in VisualChar (Ctrl-D/U)
                KeyCode::Char('d') if key.mods.contains(KeyModifiers::CTRL) => {
                    trace!(target = "actions.translate", motion = ?MotionKind::PageHalfDown, "visual_half_page");
                    Some(Action::Motion(MotionKind::PageHalfDown))
                }
                KeyCode::Char('u') if key.mods.contains(KeyModifiers::CTRL) => {
                    trace!(target = "actions.translate", motion = ?MotionKind::PageHalfUp, "visual_half_page");
                    Some(Action::Motion(MotionKind::PageHalfUp))
                }
                KeyCode::Char('h') => Some(Action::Motion(MotionKind::Left)),
                KeyCode::Char('l') => Some(Action::Motion(MotionKind::Right)),
                KeyCode::Char('j') => Some(Action::Motion(MotionKind::Down)),
                KeyCode::Char('k') => Some(Action::Motion(MotionKind::Up)),
                KeyCode::Char('0') => Some(Action::Motion(MotionKind::LineStart)),
                KeyCode::Char('$') => Some(Action::Motion(MotionKind::LineEnd)),
                KeyCode::Char('w') => Some(Action::Motion(MotionKind::WordForward)),
                KeyCode::Char('b') => Some(Action::Motion(MotionKind::WordBackward)),
                // Only treat plain 'd' (no modifiers) as Visual Delete operator.
                KeyCode::Char('d')
                    if !key.mods.contains(KeyModifiers::CTRL)
                        && !key.mods.contains(KeyModifiers::ALT) =>
                {
                    trace!(target = "actions.translate", op = ?OperatorKind::Delete, "visual_operator");
                    Some(Action::VisualOperator {
                        op: OperatorKind::Delete,
                        register: None,
                    })
                }
                // Only plain 'y' (no modifiers) as Visual Yank operator.
                KeyCode::Char('y')
                    if !key.mods.contains(KeyModifiers::CTRL)
                        && !key.mods.contains(KeyModifiers::ALT) =>
                {
                    trace!(target = "actions.translate", op = ?OperatorKind::Yank, "visual_operator");
                    Some(Action::VisualOperator {
                        op: OperatorKind::Yank,
                        register: None,
                    })
                }
                // Only plain 'c' (no modifiers) as Visual Change operator.
                KeyCode::Char('c')
                    if !key.mods.contains(KeyModifiers::CTRL)
                        && !key.mods.contains(KeyModifiers::ALT) =>
                {
                    trace!(target = "actions.translate", op = ?OperatorKind::Change, "visual_operator");
                    Some(Action::VisualOperator {
                        op: OperatorKind::Change,
                        register: None,
                    })
                }
                // Alias: Visual 'x' behaves like delete (no modifiers)
                KeyCode::Char('x')
                    if !key.mods.contains(KeyModifiers::CTRL)
                        && !key.mods.contains(KeyModifiers::ALT) =>
                {
                    trace!(target = "actions.translate", op = ?OperatorKind::Delete, "visual_operator");
                    Some(Action::VisualOperator {
                        op: OperatorKind::Delete,
                        register: None,
                    })
                }
                KeyCode::Char('v') => Some(Action::ModeChange(ModeChange::LeaveVisualChar)),
                _ => None,
            };
            return finalize_resolution(action, cfg);
        }
        // Early Insert-mode coverage: plain text insert, newline, backspace.
        if matches!(mode, Mode::Insert) {
            let action = match key.code {
                KeyCode::Char(c)
                    if !key.mods.contains(KeyModifiers::CTRL)
                        && !key.mods.contains(KeyModifiers::ALT) =>
                {
                    trace!(target = "actions.translate", kind = "insert_char");
                    Some(Action::Edit(EditKind::InsertGrapheme(c.to_string())))
                }
                KeyCode::Enter => {
                    trace!(target = "actions.translate", kind = "insert_newline");
                    Some(Action::Edit(EditKind::InsertNewline))
                }
                KeyCode::Backspace => {
                    trace!(target = "actions.translate", kind = "backspace");
                    Some(Action::Edit(EditKind::Backspace))
                }
                KeyCode::Esc => {
                    trace!(target = "actions.translate", kind = "leave_insert");
                    Some(Action::ModeChange(ModeChange::LeaveInsert))
                }
                _ => None,
            };
            return finalize_resolution(action, cfg);
        }
        // Normal mode: start command-line with ':'
        if matches!(mode, Mode::Normal)
            && let KeyCode::Char(':') = key.code
            && !key.mods.contains(KeyModifiers::CTRL)
            && !key.mods.contains(KeyModifiers::ALT)
        {
            trace!(target = "actions.translate", kind = "command_start");
            return finalize_resolution(Some(Action::CommandStart), cfg);
        }
        // Normal mode: handle Ctrl-based motions and redo directly in NGI.
        if matches!(mode, Mode::Normal) {
            match key.code {
                KeyCode::Char('d') if key.mods.contains(KeyModifiers::CTRL) => {
                    trace!(target = "actions.translate", motion = ?MotionKind::PageHalfDown, "normal_half_page");
                    return finalize_resolution(
                        Some(Action::Motion(MotionKind::PageHalfDown)),
                        cfg,
                    );
                }
                KeyCode::Char('u') if key.mods.contains(KeyModifiers::CTRL) => {
                    trace!(target = "actions.translate", motion = ?MotionKind::PageHalfUp, "normal_half_page");
                    return finalize_resolution(Some(Action::Motion(MotionKind::PageHalfUp)), cfg);
                }
                KeyCode::Char('r') if key.mods.contains(KeyModifiers::CTRL) => {
                    trace!(target = "actions.translate", kind = "redo");
                    return finalize_resolution(Some(Action::Redo), cfg);
                }
                KeyCode::Esc => {
                    // Cancel any pending operator/count/register in NGI context to mirror legacy ESC behavior.
                    #[allow(clippy::let_unit_value)]
                    {
                        core_keymap::PendingContext::default();
                    }
                    CTX.with(|ctx_cell| {
                        let mut ctx = ctx_cell.borrow_mut();
                        let _ = compose_with_context(&mut ctx, &core_keymap::MappingOutput::Esc);
                    });
                    BUFFER.with(|b| b.borrow_mut().clear());
                    PARTIAL_TIMER.with(|pt| pt.borrow_mut().clear());
                    trace!(target = "actions.translate", kind = "esc_clear");
                    return finalize_resolution(None, cfg);
                }
                _ => {}
            }
        }
        // Restrict NGI mapping trie path to Normal mode for now.
        if !matches!(mode, Mode::Normal) {
            return finalize_resolution(None, cfg); // no NGI mapping for non-Normal here
        }
        // Only plain Char codes handled in this early adapter. Defer Esc and others to legacy
        // to preserve behaviors like command cancel while NGI coverage grows.
        let ch = match key.code {
            KeyCode::Char(c) if !key.mods.contains(KeyModifiers::CTRL) => c,
            _ => return finalize_resolution(None, cfg),
        };
        let action = TRIE.with(|trie| {
            CTX.with(|ctx_cell| {
                BUFFER.with(|buf_cell| {
                    let mut ctx = ctx_cell.borrow_mut();
                    let mut buf = buf_cell.borrow_mut();
                    buf.push(ch);
                    // If we are awaiting a register (after '"'), capture alphanumeric as register name
                    // and do not feed it through the trie (avoids misclassifying 'b' as a motion).
                    if ctx.awaiting_register && ch.is_ascii_alphanumeric() {
                        let _ = compose_with_context(
                            &mut ctx,
                            &core_keymap::MappingOutput::RegisterName(ch),
                        );
                        buf.clear();
                        PARTIAL_TIMER.with(|pt| pt.borrow_mut().clear());
                        return None;
                    }
                    loop {
                        match trie.resolve(&buf) {
                            core_keymap::Resolution::Matched {
                                consumed,
                                output,
                                ambiguous,
                            } => {
                                trace!(
                                    target = "input.map",
                                    consumed,
                                    ambiguous,
                                    ?output,
                                    "ngi_resolve_matched"
                                );
                                let action = match compose_with_context(&mut ctx, &output) {
                                    ComposedAction::None => {
                                        /* continue; state only */
                                        None
                                    }
                                    ComposedAction::Motion { motion, count } => {
                                        let mk = map_motion(motion)?;
                                        if count == 1 {
                                            Some(Action::Motion(mk))
                                        } else {
                                            Some(Action::MotionWithCount { motion: mk, count })
                                        }
                                    }
                                    ComposedAction::ApplyOperator {
                                        op,
                                        motion,
                                        count,
                                        register,
                                    } => {
                                        let opk = map_operator(op)?;
                                        let mk = map_motion(motion)?;
                                        Some(Action::ApplyOperator {
                                            op: opk,
                                            motion: mk,
                                            count,
                                            register,
                                        })
                                    }
                                    ComposedAction::LinewiseOperator {
                                        op,
                                        count,
                                        register,
                                    } => {
                                        let opk = map_operator(op)?;
                                        Some(Action::LinewiseOperator {
                                            op: opk,
                                            count,
                                            register,
                                        })
                                    }
                                    ComposedAction::PasteAfter { register } => {
                                        Some(Action::PasteAfter { register })
                                    }
                                    ComposedAction::PasteBefore { register } => {
                                        Some(Action::PasteBefore { register })
                                    }
                                    ComposedAction::EnterInsert => {
                                        Some(Action::ModeChange(ModeChange::EnterInsert))
                                    }
                                    ComposedAction::Undo => Some(Action::Undo),
                                    ComposedAction::ModeToggleVisualChar => {
                                        Some(Action::ModeChange(ModeChange::EnterVisualChar))
                                    }
                                    ComposedAction::DeleteUnder => {
                                        Some(Action::Edit(EditKind::DeleteUnder))
                                    }
                                    ComposedAction::DeleteLeft => {
                                        Some(Action::Edit(EditKind::DeleteLeft))
                                    }
                                    ComposedAction::Literal(c) => Some(Action::CommandChar(c)),
                                };
                                // consume
                                buf.drain(0..consumed);
                                if action.is_some() {
                                    PARTIAL_TIMER.with(|pt| pt.borrow_mut().clear());
                                    return action;
                                }
                                if ambiguous {
                                    PARTIAL_TIMER
                                        .with(|pt| pt.borrow_mut().start(PartialKind::Generic));
                                    break;
                                } else {
                                    continue;
                                }
                            }
                            core_keymap::Resolution::FallbackLiteral(c) => {
                                trace!(target="input.map", literal=%c, "ngi_resolve_fallback");
                                // If awaiting a register after '"', consume alphanumeric as register name.
                                if ctx.awaiting_register && c.is_ascii_alphanumeric() {
                                    let _ = compose_with_context(
                                        &mut ctx,
                                        &core_keymap::MappingOutput::RegisterName(c),
                                    );
                                    buf.clear();
                                    PARTIAL_TIMER.with(|pt| pt.borrow_mut().clear());
                                    return None;
                                }
                                // Otherwise, treat as command char only if a command is active; else no action.
                                let action = if pending_command.starts_with(':') {
                                    Some(Action::CommandChar(c))
                                } else {
                                    None
                                };
                                buf.clear();
                                PARTIAL_TIMER.with(|pt| pt.borrow_mut().clear());
                                return action;
                            }
                            core_keymap::Resolution::NeedMore => {
                                PARTIAL_TIMER
                                    .with(|pt| pt.borrow_mut().start(PartialKind::Generic));
                                break; // wait for more keys
                            }
                        }
                    }
                    None
                })
            })
        });
        finalize_resolution(action, cfg)
    }

    pub fn flush_pending_literal(cfg: &Config) -> Option<NgiResolution> {
        TRIE.with(|_trie| {
            CTX.with(|_ctx_cell| {
                BUFFER.with(|buf_cell| {
                    PARTIAL_TIMER.with(|pt_cell| {
                        let mut buf = buf_cell.borrow_mut();
                        if buf.is_empty() {
                            return None;
                        }
                        let ch = buf.remove(0);
                        trace!(target = "actions.translate", kind = "timeout_flush", ch = %ch);
                        let mut pt = pt_cell.borrow_mut();
                        let pending_state = if buf.is_empty() {
                            pt.clear();
                            PendingState::Idle
                        } else {
                            pt.started = Some(Instant::now());
                            PendingState::AwaitingMore {
                                buffered_len: buf.len(),
                            }
                        };
                        let deadline = match pending_state {
                            PendingState::Idle => None,
                            PendingState::AwaitingMore { .. } => pt.deadline(cfg),
                        };
                        Some(NgiResolution::new(
                            Some(Action::CommandChar(ch)),
                            pending_state,
                            deadline,
                        ))
                    })
                })
            })
        })
    }

    fn snapshot_pending(cfg: &Config) -> (PendingState, Option<Instant>) {
        BUFFER.with(|buf_cell| {
            let len = buf_cell.borrow().len();
            PARTIAL_TIMER.with(|pt_cell| {
                let pt = pt_cell.borrow();
                if len == 0 {
                    (PendingState::Idle, None)
                } else {
                    (
                        PendingState::AwaitingMore { buffered_len: len },
                        pt.deadline(cfg),
                    )
                }
            })
        })
    }

    fn finalize_resolution(action: Option<Action>, cfg: &Config) -> NgiResolution {
        let (pending_state, deadline) = snapshot_pending(cfg);
        NgiResolution::new(action, pending_state, deadline)
    }

    fn map_motion(c: char) -> Option<MotionKind> {
        Some(match c {
            'h' => MotionKind::Left,
            'l' => MotionKind::Right,
            'j' => MotionKind::Down,
            'k' => MotionKind::Up,
            'w' => MotionKind::WordForward,
            'b' => MotionKind::WordBackward,
            '0' => MotionKind::LineStart,
            '$' => MotionKind::LineEnd,
            _ => return None,
        })
    }
    fn map_operator(c: char) -> Option<OperatorKind> {
        Some(match c {
            'd' => OperatorKind::Delete,
            'y' => OperatorKind::Yank,
            'c' => OperatorKind::Change,
            _ => return None,
        })
    }
}

pub use ngi_adapter::{NgiResolution, PendingState, flush_pending_literal, translate_ngi};

#[cfg(test)]
mod tests {
    use super::*;
    use core_events::{KeyCode, KeyEvent, KeyModifiers};
    fn kc(c: char) -> KeyEvent {
        KeyEvent {
            code: KeyCode::Char(c),
            mods: KeyModifiers::empty(),
        }
    }

    #[test]
    fn normal_mode_motion() {
        assert!(matches!(
            translate_key(Mode::Normal, "", &kc('h')),
            Some(Action::Motion(MotionKind::Left))
        ));
        assert!(translate_key(Mode::Normal, "", &kc('z')).is_none());
    }

    #[test]
    fn insert_mode_inserts() {
        assert!(
            matches!(translate_key(Mode::Insert, "", &kc('a')), Some(Action::Edit(EditKind::InsertGrapheme(ref s))) if s=="a")
        );
    }

    #[test]
    fn command_sequence_translation() {
        // start
        let start = translate_key(Mode::Normal, "", &kc(':'));
        assert!(matches!(start, Some(Action::CommandStart)));
        // after ':' pending buffer would be ':'; simulate adding 'q'
        let q = translate_key(Mode::Normal, ":", &kc('q'));
        assert!(matches!(q, Some(Action::CommandChar('q'))));
        // Enter executes
        let enter = translate_key(
            Mode::Normal,
            ":q",
            &KeyEvent {
                code: KeyCode::Enter,
                mods: KeyModifiers::empty(),
            },
        );
        assert!(matches!(enter, Some(Action::CommandExecute(ref s)) if s==":q"));
        // Esc cancels when active
        let esc = translate_key(
            Mode::Normal,
            ":q",
            &KeyEvent {
                code: KeyCode::Esc,
                mods: KeyModifiers::empty(),
            },
        );
        assert!(matches!(esc, Some(Action::CommandCancel)));
        // Backspace
        let bs = translate_key(
            Mode::Normal,
            ":q",
            &KeyEvent {
                code: KeyCode::Backspace,
                mods: KeyModifiers::empty(),
            },
        );
        assert!(matches!(bs, Some(Action::CommandBackspace)));
    }

    #[test]
    fn ctrl_r_maps_to_redo() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let evt = KeyEvent {
            code: KeyCode::Char('r'),
            mods: KeyModifiers::CTRL,
        };
        let act = translate_key(Mode::Normal, "", &evt);
        assert!(
            matches!(act, Some(Action::Redo)),
            "Ctrl-R should map to Redo action"
        );
        // Ensure plain 'r' (no ctrl) is currently unbound (reserved for future replace semantics)
        let plain = KeyEvent {
            code: KeyCode::Char('r'),
            mods: KeyModifiers::empty(),
        };
        assert!(translate_key(Mode::Normal, "", &plain).is_none());
    }

    #[test]
    fn operator_variants_constructible() {
        // Ensure the new operator-related Action variants remain reachable and compile.
        let _op = OperatorKind::Delete;
        let begin = Action::BeginOperator(_op);
        match begin {
            Action::BeginOperator(OperatorKind::Delete) => {}
            _ => panic!("Unexpected variant"),
        }
        let apply = Action::ApplyOperator {
            op: OperatorKind::Yank,
            motion: MotionKind::Left,
            count: 2,
            register: None,
        };
        if let Action::ApplyOperator {
            op,
            motion,
            count,
            register,
        } = apply
        {
            assert_eq!(op, OperatorKind::Yank);
            assert_eq!(motion, MotionKind::Left);
            assert_eq!(count, 2);
            assert!(register.is_none());
        } else {
            panic!("ApplyOperator pattern mismatch");
        }
        let linewise = Action::LinewiseOperator {
            op: OperatorKind::Delete,
            count: 3,
            register: Some('a'),
        };
        if let Action::LinewiseOperator {
            op,
            count,
            register,
        } = linewise
        {
            assert_eq!(op, OperatorKind::Delete);
            assert_eq!(count, 3);
            assert_eq!(register, Some('a'));
        } else {
            panic!("LinewiseOperator pattern mismatch");
        }
    }

    #[test]
    fn ngi_linewise_dd() {
        assert!(translate_key(Mode::Normal, "", &kc('d')).is_none());
        match translate_key(Mode::Normal, "", &kc('d')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Delete));
                assert_eq!(count, 1);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(dd) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_prefix_count_3dd() {
        assert!(translate_key(Mode::Normal, "", &kc('3')).is_none());
        assert!(translate_key(Mode::Normal, "", &kc('d')).is_none());
        match translate_key(Mode::Normal, "", &kc('d')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Delete));
                assert_eq!(count, 3);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(3dd) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_post_count_d2d() {
        assert!(translate_key(Mode::Normal, "", &kc('d')).is_none());
        assert!(translate_key(Mode::Normal, "", &kc('2')).is_none());
        match translate_key(Mode::Normal, "", &kc('d')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Delete));
                assert_eq!(count, 2);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(d2d) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_register_yy() {
        assert!(translate_key(Mode::Normal, "", &kc('"')).is_none());
        assert!(translate_key(Mode::Normal, "", &kc('a')).is_none());
        assert!(translate_key(Mode::Normal, "", &kc('y')).is_none());
        match translate_key(Mode::Normal, "", &kc('y')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Yank));
                assert_eq!(count, 1);
                assert_eq!(register, Some('a'));
            }
            other => panic!("expected LinewiseOperator(\"ayy) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_cc_change() {
        assert!(translate_key(Mode::Normal, "", &kc('c')).is_none());
        match translate_key(Mode::Normal, "", &kc('c')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Change));
                assert_eq!(count, 1);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(cc) got {:?}", other),
        }
    }

    // Removed: colon_variant_translation test (Refactor R2 Step 8) â€“ KeyCode::Colon eliminated; ':' represented solely via KeyCode::Char(':').
}
