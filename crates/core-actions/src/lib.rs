//! High-level semantic editor actions, key translation, and command dispatch.
//!
//! Scope (Refactor R3):
//! - `Action` enum models motions, edits, mode transitions, command-line lifecycle,
//!   undo/redo, and (scaffolded) operator application variants.
//! - `KeyTranslator` (stateful) replaces earlier stateless free function; currently
//!   semantics are identical while laying groundwork for count & operator-pending
//!   logic (Phase 4 enablement).
//! - Modular dispatcher (split into motion/edit/command/mode/undo submodules) reduces
//!   single-file churn and keeps future feature growth localized.
//! - Command parsing layer isolates `:commands` growth (`:metrics` stub added in Step 11).
//!
//! Design Tenets Applied:
//! - Breadth-first: operator & count variants exist but are not emitted yet.
//! - Modularity: translation, dispatch, IO helpers, and parser separated for clarity.
//! - Evolution over legacy: deprecated stateless translator path shims to the new
//!   stateful version and can be removed once Phase 4 count/operator work lands.
//!
//! Phase 4 Status:
//! - Numeric count prefixes (Step 1) now accumulate into `MotionWithCount` and are
//!   internally expanded by dispatcher logic (preserving one Action per keypress).
//! - Operator-pending + application variants (`BeginOperator`, `ApplyOperator`) are
//!   live; delete/yank/change semantics integrate with register + undo layers.
//! - Motion span resolution (Step 4) centralizes grapheme/word iteration rules so
//!   operator engines and future visual selections share identical span semantics.
//! - Future: register selection, paste, macro recording, and async action hooks.
//!
//! Forward (Phase 5+ Roadmap):
//! - Explicit register selection (`"a`), paste operators, macro record/replay.
//! - Async command execution hooks (LSP formatting, code actions) via observer
//!   extension point.

use core_config::Config;
use core_events::KeyEvent;
use core_state::Mode;
use std::time::Instant;
pub mod span_resolver; // Phase 4 Step 4
pub mod text_object; // Refactor R4 Step 15: text object trait stub

#[doc(hidden)]
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
/// Pre-Phase 4 operator kind scaffold. Variants are doc-hidden and not yet
/// produced by key translation. Introduced in Refactor R3 Step 4 to enable
/// forward-compatible wiring of operator/count logic without semantic changes.
pub enum OperatorKind {
    Delete,
    Yank,
    Change,
}

/// Observer hook (Refactor R1 Step 8): allows external components (macro recorder, analytics,
/// future plugin host) to observe Actions as they are translated and/or dispatched without
/// mutating editor state. Breadth-first: only pre-dispatch hook provided now.
///
/// Observers MUST be cheap and non-blocking; heavy work should be offloaded asynchronously.
pub trait ActionObserver: Send + Sync {
    /// Called immediately before an Action is dispatched (state not yet mutated).
    fn on_action(&self, action: &Action);
}

impl<T: ActionObserver + ?Sized> ActionObserver for &T {
    fn on_action(&self, action: &Action) {
        (**self).on_action(action)
    }
}

#[derive(Debug, Clone)]
pub enum Action {
    Motion(MotionKind),
    #[doc(hidden)]
    /// Count-prefixed motion (e.g. `5l`). Introduced Phase 4 Step 1. The
    /// translator collapses the numeric prefix and emits a single action
    /// which the dispatcher will iterate internally to preserve the one
    /// key-event => one dispatched action invariant.
    MotionWithCount {
        motion: MotionKind,
        count: u32,
    },
    Edit(EditKind),
    ModeChange(ModeChange),
    /// Undo the last change. `count` repeats undo (`3u`).
    Undo {
        count: u32,
    },
    /// Redo the next change. `count` repeats redo (`3<C-r>`).
    Redo {
        count: u32,
    },
    /// Paste after cursor (Normal mode 'p'). Supports counts and optional register prefix.
    PasteAfter {
        count: u32,
        register: Option<char>,
    },
    /// Paste before cursor (Normal mode 'P'). Supports counts and optional register prefix.
    PasteBefore {
        count: u32,
        register: Option<char>,
    },
    #[doc(hidden)]
    /// Begin an operator sequence (awaiting a motion). Not yet generated by key
    /// translation (Refactor R3 Step 4 scaffold).
    BeginOperator(OperatorKind),
    #[doc(hidden)]
    /// Apply an operator to a motion with an optional count already resolved.
    /// Not yet generated; future Phase 4 translator logic will emit.
    ApplyOperator {
        op: OperatorKind,
        motion: MotionKind,
        count: u32,
        register: Option<char>,
    },
    #[doc(hidden)]
    /// Apply an operator to an implicit linewise span (double-operator shorthand like `dd`).
    /// The translator resolves any counts and register prefixes before emitting this action.
    LinewiseOperator {
        op: OperatorKind,
        count: u32,
        register: Option<char>,
    },
    /// Apply an operator directly to the current active visual selection (Phase 5 Step 4).
    /// Emitted when pressing d/y/c (or x alias) while in VisualChar mode. The dispatcher will
    /// interpret the current selection span (if non-empty) and perform the operator
    /// semantics, then clear the selection (entering Insert for Change when applicable).
    VisualOperator {
        op: OperatorKind,
        register: Option<char>,
        count: u32,
    },
    /// Replace the current visual selection with register contents (`p`/`P` in Visual modes).
    /// `before` mirrors Normal-mode semantics (`P` inserts before, `p` after). Counts repeat
    /// the inserted text, and explicit registers mirror Vim prefix rules.
    VisualPaste {
        before: bool,
        register: Option<char>,
        count: u32,
    },
    // Command line actions (Task 7.1 Action Enum Refinement)
    CommandStart,           // begin command line (inserts leading ':')
    CommandChar(char),      // insert character into command buffer
    CommandBackspace,       // remove last character or cancel if only ':'
    CommandCancel,          // abort command (Esc)
    CommandExecute(String), // execute full buffer (still includes leading ':')
    Quit,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MotionKind {
    Left,
    Right,
    Up,
    Down,
    LineStart,
    LineEnd,
    WordForward,
    WordBackward,
    /// Half page down (Phase 2 Step 11)
    PageHalfDown,
    /// Half page up (Phase 2 Step 11)
    PageHalfUp,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum EditKind {
    InsertGrapheme(String),
    InsertNewline,
    Backspace,
    DeleteUnder { count: u32, register: Option<char> },
    DeleteLeft { count: u32, register: Option<char> },
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ModeChange {
    EnterInsert,
    LeaveInsert,
    EnterVisualChar,
    LeaveVisualChar,
}

/// Public translation API. NGI adapter is now the single translation path.
pub fn translate_key(
    translator: &mut ngi_adapter::NgiTranslator,
    mode: Mode,
    pending_command: &str,
    key: &KeyEvent,
) -> Option<Action> {
    translate_key_with_config(translator, mode, pending_command, key, &Config::default())
}

pub fn translate_key_with_config(
    translator: &mut ngi_adapter::NgiTranslator,
    mode: Mode,
    pending_command: &str,
    key: &KeyEvent,
    cfg: &Config,
) -> Option<Action> {
    crate::ngi_adapter::translate_ngi(translator, mode, pending_command, key, cfg, Instant::now())
        .action
}

pub mod dispatcher;
pub mod io_ops; // Refactor R2 Step 5: file IO helpers

pub use dispatcher::dispatch; // re-export for test convenience (Phase 5 Visual operators)

// -------------------------------------------------------------------------------------------------
// NGI Adapter: maps key sequences via core-keymap to existing Action enum.
// -------------------------------------------------------------------------------------------------
pub mod ngi_adapter {
    use super::{Action, EditKind, Mode, ModeChange, MotionKind, OperatorKind};
    use core_config::Config; // for timeout settings (passed in future wiring)
    use core_events::{KeyCode, KeyEvent, KeyEventExt, KeyModifiers, KeyToken, ModMask, NamedKey};
    use core_keymap::{
        ComposedAction, MappingTrie, PendingContext, baseline_normal_specs, compose_with_context,
    };
    use std::time::{Duration, Instant};
    use tracing::{debug, trace};

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    enum PartialKind {
        Generic,
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum PendingState {
        Idle,
        AwaitingMore { buffered_len: usize },
    }

    #[derive(Debug, Clone, PartialEq, Eq)]
    enum KeypressMapping {
        Supported {
            key_event: KeyEvent,
            dropped_mods: ModMask,
        },
        Unsupported {
            dropped_mods: ModMask,
        },
    }

    fn map_keypress(keypress: &KeyEventExt) -> KeypressMapping {
        let (base_token, accumulated_mods) = flatten_token(&keypress.token);
        let (key_mods, dropped_mods) = convert_mod_mask(accumulated_mods);

        match keycode_from_token(&base_token) {
            Some(code) => KeypressMapping::Supported {
                key_event: KeyEvent {
                    code,
                    mods: key_mods,
                },
                dropped_mods,
            },
            None => KeypressMapping::Unsupported { dropped_mods },
        }
    }

    fn flatten_token(token: &KeyToken) -> (KeyToken, ModMask) {
        match token {
            KeyToken::Chord { base, mods } => {
                let (inner, inner_mods) = flatten_token(base);
                (inner, *mods | inner_mods)
            }
            other => (other.clone(), ModMask::empty()),
        }
    }

    fn keycode_from_token(token: &KeyToken) -> Option<KeyCode> {
        match token {
            KeyToken::Char(c) => Some(KeyCode::Char(*c)),
            KeyToken::Named(named) => match named {
                NamedKey::Enter => Some(KeyCode::Enter),
                NamedKey::Esc => Some(KeyCode::Esc),
                NamedKey::Backspace => Some(KeyCode::Backspace),
                NamedKey::Tab => Some(KeyCode::Tab),
                NamedKey::Up => Some(KeyCode::Up),
                NamedKey::Down => Some(KeyCode::Down),
                NamedKey::Left => Some(KeyCode::Left),
                NamedKey::Right => Some(KeyCode::Right),
                _ => None,
            },
            KeyToken::Chord { .. } => None,
        }
    }

    fn convert_mod_mask(mods: ModMask) -> (KeyModifiers, ModMask) {
        let supported = ModMask::CTRL | ModMask::ALT | ModMask::SHIFT;
        let kept = mods & supported;
        let dropped = mods & !supported;

        let mut key_mods = KeyModifiers::empty();
        if kept.contains(ModMask::CTRL) {
            key_mods |= KeyModifiers::CTRL;
        }
        if kept.contains(ModMask::ALT) {
            key_mods |= KeyModifiers::ALT;
        }
        if kept.contains(ModMask::SHIFT) {
            key_mods |= KeyModifiers::SHIFT;
        }

        (key_mods, dropped)
    }

    #[cfg(test)]
    mod ingest_tests {
        use super::*;

        #[test]
        fn ingest_char_token_translates_motion() {
            let mut translator = NgiTranslator::new();
            let keypress = KeyEventExt::new(KeyToken::Char('h'));
            let resolution =
                translator.ingest_keypress(Mode::Normal, "", &keypress, &Config::default());
            assert!(matches!(
                resolution.action,
                Some(Action::Motion(MotionKind::Left))
            ));
        }

        #[test]
        fn ingest_ctrl_chord_translates_motion() {
            let mut translator = NgiTranslator::new();
            let keypress = KeyEventExt::new(KeyToken::Chord {
                base: Box::new(KeyToken::Char('d')),
                mods: ModMask::CTRL,
            });
            let resolution =
                translator.ingest_keypress(Mode::Normal, "", &keypress, &Config::default());
            assert!(matches!(
                resolution.action,
                Some(Action::Motion(MotionKind::PageHalfDown))
            ));
        }

        #[test]
        fn ingest_unsupported_named_key_yields_no_action() {
            let mut translator = NgiTranslator::new();
            let keypress = KeyEventExt::new(KeyToken::Named(NamedKey::Home));
            let resolution =
                translator.ingest_keypress(Mode::Normal, "", &keypress, &Config::default());
            assert!(resolution.action.is_none());
            assert!(matches!(resolution.pending_state, PendingState::Idle));
        }
    }

    #[derive(Debug, Clone)]
    pub struct NgiResolution {
        pub action: Option<Action>,
        pub pending_state: PendingState,
        pub timeout_deadline: Option<Instant>,
    }

    impl NgiResolution {
        fn new(
            action: Option<Action>,
            pending_state: PendingState,
            timeout_deadline: Option<Instant>,
        ) -> Self {
            Self {
                action,
                pending_state,
                timeout_deadline,
            }
        }
    }

    #[derive(Debug, Default)]
    struct PartialTimeoutState {
        kind: Option<PartialKind>,
        started: Option<Instant>,
    }

    impl PartialTimeoutState {
        const fn new() -> Self {
            Self {
                kind: None,
                started: None,
            }
        }
        fn start(&mut self, kind: PartialKind, at: Instant) {
            if self.kind.is_none() {
                self.kind = Some(kind);
                trace!(target: "actions.translate", kind = "timeout_start");
            }
            if self.started.is_none() {
                self.started = Some(at);
            }
        }
        fn restart(&mut self, at: Instant) {
            if self.kind.is_some() {
                self.started = Some(at);
            }
        }
        fn clear(&mut self) {
            if self.kind.is_some() {
                trace!(target: "actions.translate", kind = "timeout_clear");
            }
            self.kind = None;
            self.started = None;
        }
        fn deadline(&self, cfg: &Config) -> Option<Instant> {
            if !cfg.file.input.timeout {
                return None;
            }
            self.started
                .map(|start| start + Duration::from_millis(cfg.file.input.timeoutlen as u64))
        }
    }

    #[derive(Debug)]
    pub struct NgiTranslator {
        trie: MappingTrie,
        ctx: PendingContext,
        buffer: Vec<char>,
        partial_timer: PartialTimeoutState,
    }

    impl NgiTranslator {
        pub fn new() -> Self {
            Self {
                trie: MappingTrie::build(baseline_normal_specs()),
                ctx: PendingContext::default(),
                buffer: Vec::new(),
                partial_timer: PartialTimeoutState::new(),
            }
        }

        pub fn reset_for_mode(&mut self, mode: Mode) {
            self.cancel_pending();
            if matches!(mode, Mode::Insert) {
                self.ctx.register = None;
            }
        }

        pub fn cancel_pending(&mut self) {
            let _ = compose_with_context(&mut self.ctx, &core_keymap::MappingOutput::Esc);
            self.buffer.clear();
            self.partial_timer.clear();
        }

        pub fn ingest_keypress(
            &mut self,
            mode: Mode,
            pending_command: &str,
            keypress: &KeyEventExt,
            cfg: &Config,
        ) -> NgiResolution {
            match map_keypress(keypress) {
                KeypressMapping::Supported {
                    key_event,
                    dropped_mods,
                } => {
                    if !dropped_mods.is_empty() {
                        debug!(
                            target: "actions.translate",
                            dropped_mods = ?dropped_mods,
                            chord = ?keypress.token,
                            "keypress_mods_dropped"
                        );
                    }
                    trace!(
                        target: "actions.translate",
                        kind = "keypress_ingest",
                        repeat = keypress.repeat,
                        timestamp = ?keypress.timestamp,
                        chord = ?keypress.token
                    );
                    self.translate(mode, pending_command, &key_event, cfg, keypress.timestamp)
                }
                KeypressMapping::Unsupported { dropped_mods } => {
                    trace!(
                        target: "actions.translate",
                        kind = "keypress_unsupported",
                        repeat = keypress.repeat,
                        timestamp = ?keypress.timestamp,
                        chord = ?keypress.token,
                        dropped_mods = ?dropped_mods
                    );
                    self.finalize_resolution(None, cfg)
                }
            }
        }

        pub fn translate(
            &mut self,
            mode: Mode,
            pending_command: &str,
            key: &KeyEvent,
            cfg: &Config,
            timestamp: Instant,
        ) -> NgiResolution {
            if pending_command.starts_with(':') {
                let action = match key.code {
                    KeyCode::Char(c)
                        if !key.mods.contains(KeyModifiers::CTRL)
                            && !key.mods.contains(KeyModifiers::ALT) =>
                    {
                        trace!(target: "actions.translate", kind = "command_char");
                        Some(Action::CommandChar(c))
                    }
                    KeyCode::Enter => {
                        trace!(
                            target: "actions.translate",
                            kind = "command_execute",
                            len = pending_command.len()
                        );
                        Some(Action::CommandExecute(pending_command.to_string()))
                    }
                    KeyCode::Backspace => {
                        trace!(target: "actions.translate", kind = "command_backspace");
                        Some(Action::CommandBackspace)
                    }
                    KeyCode::Esc => {
                        trace!(target: "actions.translate", kind = "command_cancel");
                        Some(Action::CommandCancel)
                    }
                    _ => None,
                };
                return self.finalize_resolution(action, cfg);
            }

            if matches!(mode, Mode::VisualChar) {
                self.buffer.clear();
                self.partial_timer.clear();
                let ctx = &mut self.ctx;
                let action = if key.mods.contains(KeyModifiers::CTRL) {
                    match key.code {
                        KeyCode::Char('d') => {
                            trace!(target: "actions.translate", motion = ?MotionKind::PageHalfDown, "visual_half_page");
                            Some(emit_visual_motion(MotionKind::PageHalfDown, ctx))
                        }
                        KeyCode::Char('u') => {
                            trace!(target: "actions.translate", motion = ?MotionKind::PageHalfUp, "visual_half_page");
                            Some(emit_visual_motion(MotionKind::PageHalfUp, ctx))
                        }
                        _ => None,
                    }
                } else {
                    match key.code {
                        KeyCode::Esc => {
                            ctx.reset_transient();
                            ctx.register = None;
                            trace!(target: "actions.translate", kind = "leave_visual_char");
                            Some(Action::ModeChange(ModeChange::LeaveVisualChar))
                        }
                        KeyCode::Char('"') => {
                            ctx.awaiting_register = true;
                            ctx.register = None;
                            debug!(
                                target: "input.context",
                                awaiting_register = true,
                                "visual_register_prefix"
                            );
                            None
                        }
                        KeyCode::Char(c) if ctx.awaiting_register => {
                            if c.is_ascii_alphanumeric() {
                                ctx.register = Some(c);
                                ctx.awaiting_register = false;
                                debug!(target: "input.context", register = %c, "visual_register_set");
                            }
                            None
                        }
                        KeyCode::Char(c @ '1'..='9') => {
                            extend_visual_count(ctx, c);
                            None
                        }
                        KeyCode::Char('0') => {
                            if ctx.count_prefix.is_some() {
                                extend_visual_count(ctx, '0');
                                None
                            } else {
                                Some(emit_visual_motion(MotionKind::LineStart, ctx))
                            }
                        }
                        KeyCode::Char('$') => Some(emit_visual_motion(MotionKind::LineEnd, ctx)),
                        KeyCode::Char('h') => Some(emit_visual_motion(MotionKind::Left, ctx)),
                        KeyCode::Char('l') => Some(emit_visual_motion(MotionKind::Right, ctx)),
                        KeyCode::Char('j') => Some(emit_visual_motion(MotionKind::Down, ctx)),
                        KeyCode::Char('k') => Some(emit_visual_motion(MotionKind::Up, ctx)),
                        KeyCode::Left => Some(emit_visual_motion(MotionKind::Left, ctx)),
                        KeyCode::Right => Some(emit_visual_motion(MotionKind::Right, ctx)),
                        KeyCode::Up => Some(emit_visual_motion(MotionKind::Up, ctx)),
                        KeyCode::Down => Some(emit_visual_motion(MotionKind::Down, ctx)),
                        KeyCode::Char('w') => {
                            Some(emit_visual_motion(MotionKind::WordForward, ctx))
                        }
                        KeyCode::Char('b') => {
                            Some(emit_visual_motion(MotionKind::WordBackward, ctx))
                        }
                        KeyCode::Char('d')
                        | KeyCode::Char('y')
                        | KeyCode::Char('c')
                        | KeyCode::Char('x') => {
                            let op = match key.code {
                                KeyCode::Char('d') | KeyCode::Char('x') => OperatorKind::Delete,
                                KeyCode::Char('y') => OperatorKind::Yank,
                                KeyCode::Char('c') => OperatorKind::Change,
                                _ => unreachable!(),
                            };
                            let (count, register) = take_visual_prefix(ctx);
                            trace!(target: "actions.translate", op = ?op, count, register = ?register, "visual_operator");
                            Some(Action::VisualOperator {
                                op,
                                register,
                                count,
                            })
                        }
                        KeyCode::Char('p') => {
                            let (count, register) = take_visual_prefix(ctx);
                            trace!(target: "actions.translate", before = false, count, register = ?register, "visual_paste");
                            Some(Action::VisualPaste {
                                before: false,
                                register,
                                count,
                            })
                        }
                        KeyCode::Char('P') => {
                            let (count, register) = take_visual_prefix(ctx);
                            trace!(target: "actions.translate", before = true, count, register = ?register, "visual_paste");
                            Some(Action::VisualPaste {
                                before: true,
                                register,
                                count,
                            })
                        }
                        KeyCode::Char('v') => {
                            ctx.reset_transient();
                            ctx.register = None;
                            Some(Action::ModeChange(ModeChange::LeaveVisualChar))
                        }
                        _ => None,
                    }
                };
                return self.finalize_resolution(action, cfg);
            }

            if matches!(mode, Mode::Insert) {
                let action = match key.code {
                    KeyCode::Char(c)
                        if !key.mods.contains(KeyModifiers::CTRL)
                            && !key.mods.contains(KeyModifiers::ALT) =>
                    {
                        trace!(target: "actions.translate", kind = "insert_char");
                        Some(Action::Edit(EditKind::InsertGrapheme(c.to_string())))
                    }
                    KeyCode::Enter => {
                        trace!(target: "actions.translate", kind = "insert_newline");
                        Some(Action::Edit(EditKind::InsertNewline))
                    }
                    KeyCode::Backspace => {
                        trace!(target: "actions.translate", kind = "backspace");
                        Some(Action::Edit(EditKind::Backspace))
                    }
                    KeyCode::Esc => {
                        trace!(target: "actions.translate", kind = "leave_insert");
                        Some(Action::ModeChange(ModeChange::LeaveInsert))
                    }
                    _ => None,
                };
                return self.finalize_resolution(action, cfg);
            }

            if matches!(mode, Mode::Normal)
                && matches!(key.code, KeyCode::Char(':'))
                && !key.mods.contains(KeyModifiers::CTRL)
                && !key.mods.contains(KeyModifiers::ALT)
            {
                trace!(target: "actions.translate", kind = "command_start");
                return self.finalize_resolution(Some(Action::CommandStart), cfg);
            }

            if matches!(mode, Mode::Normal) {
                match key.code {
                    KeyCode::Left => {
                        trace!(target: "actions.translate", motion = ?MotionKind::Left, "normal_named_motion");
                        return self
                            .finalize_resolution(Some(Action::Motion(MotionKind::Left)), cfg);
                    }
                    KeyCode::Right => {
                        trace!(target: "actions.translate", motion = ?MotionKind::Right, "normal_named_motion");
                        return self
                            .finalize_resolution(Some(Action::Motion(MotionKind::Right)), cfg);
                    }
                    KeyCode::Up => {
                        trace!(target: "actions.translate", motion = ?MotionKind::Up, "normal_named_motion");
                        return self.finalize_resolution(Some(Action::Motion(MotionKind::Up)), cfg);
                    }
                    KeyCode::Down => {
                        trace!(target: "actions.translate", motion = ?MotionKind::Down, "normal_named_motion");
                        return self
                            .finalize_resolution(Some(Action::Motion(MotionKind::Down)), cfg);
                    }
                    KeyCode::Char('d') if key.mods.contains(KeyModifiers::CTRL) => {
                        trace!(target: "actions.translate", motion = ?MotionKind::PageHalfDown, "normal_half_page");
                        return self.finalize_resolution(
                            Some(Action::Motion(MotionKind::PageHalfDown)),
                            cfg,
                        );
                    }
                    KeyCode::Char('u') if key.mods.contains(KeyModifiers::CTRL) => {
                        trace!(target: "actions.translate", motion = ?MotionKind::PageHalfUp, "normal_half_page");
                        return self.finalize_resolution(
                            Some(Action::Motion(MotionKind::PageHalfUp)),
                            cfg,
                        );
                    }
                    KeyCode::Char('r') if key.mods.contains(KeyModifiers::CTRL) => {
                        let count = self.ctx.count_prefix.take().unwrap_or(1).max(1);
                        self.ctx.operator = None;
                        self.ctx.post_op_count = None;
                        self.ctx.register = None;
                        self.ctx.awaiting_register = false;
                        trace!(target: "actions.translate", kind = "redo", count);
                        return self.finalize_resolution(Some(Action::Redo { count }), cfg);
                    }
                    KeyCode::Esc => {
                        let _ =
                            compose_with_context(&mut self.ctx, &core_keymap::MappingOutput::Esc);
                        self.buffer.clear();
                        self.partial_timer.clear();
                        trace!(target: "actions.translate", kind = "esc_clear");
                        return self.finalize_resolution(None, cfg);
                    }
                    _ => {}
                }
            }

            if !matches!(mode, Mode::Normal) {
                return self.finalize_resolution(None, cfg);
            }

            let KeyCode::Char(ch) = key.code else {
                return self.finalize_resolution(None, cfg);
            };
            if key.mods.contains(KeyModifiers::CTRL) {
                return self.finalize_resolution(None, cfg);
            }

            self.buffer.push(ch);

            if self.ctx.awaiting_register && ch.is_ascii_alphanumeric() {
                let _ = compose_with_context(
                    &mut self.ctx,
                    &core_keymap::MappingOutput::RegisterName(ch),
                );
                self.buffer.clear();
                self.partial_timer.clear();
                return self.finalize_resolution(None, cfg);
            }

            loop {
                match self.trie.resolve(&self.buffer) {
                    core_keymap::Resolution::Matched {
                        consumed,
                        output,
                        ambiguous,
                    } => {
                        trace!(
                            target: "input.map",
                            consumed,
                            ambiguous,
                            ?output,
                            "ngi_resolve_matched"
                        );
                        let action = match compose_with_context(&mut self.ctx, &output) {
                            ComposedAction::None => None,
                            ComposedAction::Motion { motion, count } => {
                                if let Some(mk) = map_motion(motion) {
                                    if count == 1 {
                                        Some(Action::Motion(mk))
                                    } else {
                                        Some(Action::MotionWithCount { motion: mk, count })
                                    }
                                } else {
                                    None
                                }
                            }
                            ComposedAction::ApplyOperator {
                                op,
                                motion,
                                count,
                                register,
                            } => {
                                if let (Some(opk), Some(mk)) =
                                    (map_operator(op), map_motion(motion))
                                {
                                    Some(Action::ApplyOperator {
                                        op: opk,
                                        motion: mk,
                                        count,
                                        register,
                                    })
                                } else {
                                    None
                                }
                            }
                            ComposedAction::LinewiseOperator {
                                op,
                                count,
                                register,
                            } => map_operator(op).map(|opk| Action::LinewiseOperator {
                                op: opk,
                                count,
                                register,
                            }),
                            ComposedAction::PasteAfter { count, register } => {
                                Some(Action::PasteAfter { count, register })
                            }
                            ComposedAction::PasteBefore { count, register } => {
                                Some(Action::PasteBefore { count, register })
                            }
                            ComposedAction::EnterInsert => {
                                Some(Action::ModeChange(ModeChange::EnterInsert))
                            }
                            ComposedAction::Undo { count } => Some(Action::Undo { count }),
                            ComposedAction::ModeToggleVisualChar => {
                                Some(Action::ModeChange(ModeChange::EnterVisualChar))
                            }
                            ComposedAction::DeleteUnder { count, register } => {
                                Some(Action::Edit(EditKind::DeleteUnder { count, register }))
                            }
                            ComposedAction::DeleteLeft { count, register } => {
                                Some(Action::Edit(EditKind::DeleteLeft { count, register }))
                            }
                            ComposedAction::Literal(c) => Some(Action::CommandChar(c)),
                        };

                        self.buffer.drain(0..consumed);
                        if let Some(action) = action {
                            self.partial_timer.clear();
                            return self.finalize_resolution(Some(action), cfg);
                        }
                        if ambiguous {
                            self.partial_timer.start(PartialKind::Generic, timestamp);
                            break;
                        }
                    }
                    core_keymap::Resolution::FallbackLiteral(c) => {
                        trace!(target: "input.map", literal = %c, "ngi_resolve_fallback");
                        if self.ctx.awaiting_register && c.is_ascii_alphanumeric() {
                            let _ = compose_with_context(
                                &mut self.ctx,
                                &core_keymap::MappingOutput::RegisterName(c),
                            );
                            self.buffer.clear();
                            self.partial_timer.clear();
                            return self.finalize_resolution(None, cfg);
                        }
                        if pending_command.starts_with(':') {
                            let action = Some(Action::CommandChar(c));
                            self.buffer.clear();
                            self.partial_timer.clear();
                            return self.finalize_resolution(action, cfg);
                        }
                        self.partial_timer.start(PartialKind::Generic, timestamp);
                        break;
                    }
                    core_keymap::Resolution::NeedMore => {
                        self.partial_timer.start(PartialKind::Generic, timestamp);
                        break;
                    }
                }
            }

            self.finalize_resolution(None, cfg)
        }

        pub fn flush_pending_literal(
            &mut self,
            cfg: &Config,
            now: Instant,
        ) -> Option<NgiResolution> {
            if self.buffer.is_empty() {
                return None;
            }
            let ch = self.buffer.remove(0);
            trace!(target: "actions.translate", kind = "timeout_flush", ch = %ch);
            let pending_state = if self.buffer.is_empty() {
                self.partial_timer.clear();
                PendingState::Idle
            } else {
                self.partial_timer.restart(now);
                PendingState::AwaitingMore {
                    buffered_len: self.buffer.len(),
                }
            };
            let deadline = match pending_state {
                PendingState::Idle => None,
                PendingState::AwaitingMore { .. } => self.partial_timer.deadline(cfg),
            };
            Some(NgiResolution::new(
                Some(Action::CommandChar(ch)),
                pending_state,
                deadline,
            ))
        }

        fn finalize_resolution(&mut self, action: Option<Action>, cfg: &Config) -> NgiResolution {
            let (pending_state, deadline) = self.snapshot_pending(cfg);
            NgiResolution::new(action, pending_state, deadline)
        }

        fn snapshot_pending(&self, cfg: &Config) -> (PendingState, Option<Instant>) {
            if self.buffer.is_empty() {
                (PendingState::Idle, None)
            } else {
                (
                    PendingState::AwaitingMore {
                        buffered_len: self.buffer.len(),
                    },
                    self.partial_timer.deadline(cfg),
                )
            }
        }
    }

    impl Default for NgiTranslator {
        fn default() -> Self {
            Self::new()
        }
    }

    pub fn translate_keypress(
        translator: &mut NgiTranslator,
        mode: Mode,
        pending_command: &str,
        keypress: &KeyEventExt,
        cfg: &Config,
    ) -> NgiResolution {
        translator.ingest_keypress(mode, pending_command, keypress, cfg)
    }

    pub fn translate_ngi(
        translator: &mut NgiTranslator,
        mode: Mode,
        pending_command: &str,
        key: &KeyEvent,
        cfg: &Config,
        timestamp: Instant,
    ) -> NgiResolution {
        translator.translate(mode, pending_command, key, cfg, timestamp)
    }

    pub fn flush_pending_literal(
        translator: &mut NgiTranslator,
        cfg: &Config,
        now: Instant,
    ) -> Option<NgiResolution> {
        translator.flush_pending_literal(cfg, now)
    }

    fn map_motion(c: char) -> Option<MotionKind> {
        Some(match c {
            'h' => MotionKind::Left,
            'l' => MotionKind::Right,
            'j' => MotionKind::Down,
            'k' => MotionKind::Up,
            'w' => MotionKind::WordForward,
            'b' => MotionKind::WordBackward,
            '0' => MotionKind::LineStart,
            '$' => MotionKind::LineEnd,
            _ => return None,
        })
    }

    fn map_operator(c: char) -> Option<OperatorKind> {
        Some(match c {
            'd' => OperatorKind::Delete,
            'y' => OperatorKind::Yank,
            'c' => OperatorKind::Change,
            _ => return None,
        })
    }

    fn extend_visual_count(ctx: &mut PendingContext, digit: char) {
        let value = (digit as u8 - b'0') as u32;
        let new_val = ctx
            .count_prefix
            .unwrap_or(0)
            .saturating_mul(10)
            .saturating_add(value)
            .min(999_999);
        ctx.count_prefix = Some(new_val);
        debug!(target: "input.context", count_prefix = new_val, digit = %digit, "visual_count_extend");
    }

    fn take_visual_prefix(ctx: &mut PendingContext) -> (u32, Option<char>) {
        let count = ctx.count_prefix.take().unwrap_or(1).max(1);
        let register = ctx.register.take();
        ctx.awaiting_register = false;
        ctx.operator = None;
        ctx.post_op_count = None;
        (count, register)
    }

    fn emit_visual_motion(kind: MotionKind, ctx: &mut PendingContext) -> Action {
        let (count, _) = take_visual_prefix(ctx);
        if count > 1 {
            Action::MotionWithCount {
                motion: kind,
                count,
            }
        } else {
            Action::Motion(kind)
        }
    }
}

pub use ngi_adapter::{
    NgiResolution, NgiTranslator, PendingState, flush_pending_literal, translate_keypress,
    translate_ngi,
};

#[cfg(test)]
mod tests {
    use super::*;
    use core_config::Config;
    use core_events::{KeyCode, KeyEvent, KeyEventExt, KeyModifiers, KeyToken, NamedKey};
    use std::time::Instant;

    fn new_translator() -> NgiTranslator {
        NgiTranslator::new()
    }
    fn kc(c: char) -> KeyEvent {
        KeyEvent {
            code: KeyCode::Char(c),
            mods: KeyModifiers::empty(),
        }
    }

    #[test]
    fn normal_mode_motion() {
        let mut translator = new_translator();
        assert!(matches!(
            translate_key(&mut translator, Mode::Normal, "", &kc('h')),
            Some(Action::Motion(MotionKind::Left))
        ));
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('z')).is_none());
    }

    #[test]
    fn insert_mode_inserts() {
        let mut translator = new_translator();
        assert!(matches!(
            translate_key(&mut translator, Mode::Insert, "", &kc('a')),
            Some(Action::Edit(EditKind::InsertGrapheme(ref s))) if s=="a"
        ));
    }

    #[test]
    fn command_sequence_translation() {
        let mut translator = new_translator();
        // start
        let start = translate_key(&mut translator, Mode::Normal, "", &kc(':'));
        assert!(matches!(start, Some(Action::CommandStart)));
        // after ':' pending buffer would be ':'; simulate adding 'q'
        let q = translate_key(&mut translator, Mode::Normal, ":", &kc('q'));
        assert!(matches!(q, Some(Action::CommandChar('q'))));
        // Enter executes
        let enter = translate_key(
            &mut translator,
            Mode::Normal,
            ":q",
            &KeyEvent {
                code: KeyCode::Enter,
                mods: KeyModifiers::empty(),
            },
        );
        assert!(matches!(enter, Some(Action::CommandExecute(ref s)) if s==":q"));
        // Esc cancels when active
        let esc = translate_key(
            &mut translator,
            Mode::Normal,
            ":q",
            &KeyEvent {
                code: KeyCode::Esc,
                mods: KeyModifiers::empty(),
            },
        );
        assert!(matches!(esc, Some(Action::CommandCancel)));
        // Backspace
        let bs = translate_key(
            &mut translator,
            Mode::Normal,
            ":q",
            &KeyEvent {
                code: KeyCode::Backspace,
                mods: KeyModifiers::empty(),
            },
        );
        assert!(matches!(bs, Some(Action::CommandBackspace)));
    }

    #[test]
    fn ctrl_r_maps_to_redo() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let evt = KeyEvent {
            code: KeyCode::Char('r'),
            mods: KeyModifiers::CTRL,
        };
        let act = translate_key(&mut translator, Mode::Normal, "", &evt);
        assert!(
            matches!(act, Some(Action::Redo { count }) if count == 1),
            "Ctrl-R should map to Redo action"
        );
        // Ensure plain 'r' (no ctrl) is currently unbound (reserved for future replace semantics)
        let plain = KeyEvent {
            code: KeyCode::Char('r'),
            mods: KeyModifiers::empty(),
        };
        assert!(translate_key(&mut translator, Mode::Normal, "", &plain).is_none());
    }

    #[test]
    fn ctrl_r_respects_count_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('3')).is_none());
        let ctrl_r = KeyEvent {
            code: KeyCode::Char('r'),
            mods: KeyModifiers::CTRL,
        };
        match translate_key(&mut translator, Mode::Normal, "", &ctrl_r) {
            Some(Action::Redo { count }) => assert_eq!(count, 3),
            other => panic!("expected Redo with count 3, got {:?}", other),
        }
    }

    #[test]
    fn ngi_delete_under_count_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('3')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('x')) {
            Some(Action::Edit(EditKind::DeleteUnder { count, register })) => {
                assert_eq!(count, 3);
                assert!(register.is_none());
            }
            other => panic!("expected DeleteUnder with count 3, got {:?}", other),
        }
    }

    #[test]
    fn ngi_delete_under_register_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('"')).is_none());
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('a')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('x')) {
            Some(Action::Edit(EditKind::DeleteUnder { count, register })) => {
                assert_eq!(count, 1);
                assert_eq!(register, Some('a'));
            }
            other => panic!("expected DeleteUnder with register a, got {:?}", other),
        }
    }

    #[test]
    fn ngi_delete_left_count_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('2')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('X')) {
            Some(Action::Edit(EditKind::DeleteLeft { count, register })) => {
                assert_eq!(count, 2);
                assert!(register.is_none());
            }
            other => panic!("expected DeleteLeft with count 2, got {:?}", other),
        }
    }

    #[test]
    fn ngi_paste_after_count_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('4')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('p')) {
            Some(Action::PasteAfter { count, register }) => {
                assert_eq!(count, 4);
                assert!(register.is_none());
            }
            other => panic!("expected PasteAfter with count 4, got {:?}", other),
        }
    }

    #[test]
    fn ngi_paste_after_register_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('"')).is_none());
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('b')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('p')) {
            Some(Action::PasteAfter { count, register }) => {
                assert_eq!(count, 1);
                assert_eq!(register, Some('b'));
            }
            other => panic!("expected PasteAfter with register b, got {:?}", other),
        }
    }

    #[test]
    fn ngi_paste_before_count_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('2')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('P')) {
            Some(Action::PasteBefore { count, register }) => {
                assert_eq!(count, 2);
                assert!(register.is_none());
            }
            other => panic!("expected PasteBefore with count 2, got {:?}", other),
        }
    }

    #[test]
    fn ngi_paste_before_register_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('"')).is_none());
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('C')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('P')) {
            Some(Action::PasteBefore { count, register }) => {
                assert_eq!(count, 1);
                assert_eq!(register, Some('C'));
            }
            other => panic!("expected PasteBefore with register C, got {:?}", other),
        }
    }

    #[test]
    fn ngi_undo_count_prefix() {
        use core_events::{KeyCode, KeyEvent, KeyModifiers};
        let mut translator = new_translator();
        let esc = KeyEvent {
            code: KeyCode::Esc,
            mods: KeyModifiers::empty(),
        };
        let _ = translate_key(&mut translator, Mode::Normal, "", &esc);
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('5')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('u')) {
            Some(Action::Undo { count }) => assert_eq!(count, 5),
            other => panic!("expected Undo with count 5, got {:?}", other),
        }
    }

    #[test]
    fn operator_variants_constructible() {
        // Ensure the new operator-related Action variants remain reachable and compile.
        let _op = OperatorKind::Delete;
        let begin = Action::BeginOperator(_op);
        match begin {
            Action::BeginOperator(OperatorKind::Delete) => {}
            _ => panic!("Unexpected variant"),
        }
        let apply = Action::ApplyOperator {
            op: OperatorKind::Yank,
            motion: MotionKind::Left,
            count: 2,
            register: None,
        };
        if let Action::ApplyOperator {
            op,
            motion,
            count,
            register,
        } = apply
        {
            assert_eq!(op, OperatorKind::Yank);
            assert_eq!(motion, MotionKind::Left);
            assert_eq!(count, 2);
            assert!(register.is_none());
        } else {
            panic!("ApplyOperator pattern mismatch");
        }
        let linewise = Action::LinewiseOperator {
            op: OperatorKind::Delete,
            count: 3,
            register: Some('a'),
        };
        if let Action::LinewiseOperator {
            op,
            count,
            register,
        } = linewise
        {
            assert_eq!(op, OperatorKind::Delete);
            assert_eq!(count, 3);
            assert_eq!(register, Some('a'));
        } else {
            panic!("LinewiseOperator pattern mismatch");
        }
    }

    #[test]
    fn ngi_linewise_dd() {
        let mut translator = new_translator();
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('d')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('d')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Delete));
                assert_eq!(count, 1);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(dd) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_prefix_count_3dd() {
        let mut translator = new_translator();
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('3')).is_none());
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('d')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('d')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Delete));
                assert_eq!(count, 3);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(3dd) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_post_count_d2d() {
        let mut translator = new_translator();
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('d')).is_none());
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('2')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('d')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Delete));
                assert_eq!(count, 2);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(d2d) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_register_yy() {
        let mut translator = new_translator();
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('"')).is_none());
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('a')).is_none());
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('y')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('y')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Yank));
                assert_eq!(count, 1);
                assert_eq!(register, Some('a'));
            }
            other => panic!("expected LinewiseOperator(\"ayy) got {:?}", other),
        }
    }

    #[test]
    fn ngi_linewise_cc_change() {
        let mut translator = new_translator();
        assert!(translate_key(&mut translator, Mode::Normal, "", &kc('c')).is_none());
        match translate_key(&mut translator, Mode::Normal, "", &kc('c')) {
            Some(Action::LinewiseOperator {
                op,
                count,
                register,
            }) => {
                assert!(matches!(op, OperatorKind::Change));
                assert_eq!(count, 1);
                assert!(register.is_none());
            }
            other => panic!("expected LinewiseOperator(cc) got {:?}", other),
        }
    }

    #[test]
    fn named_arrow_translates_to_motion() {
        let cfg = Config::default();
        let mut translator = new_translator();
        let left = KeyEventExt::from_parts(KeyToken::Named(NamedKey::Left), false, Instant::now());
        let resolution = translate_keypress(&mut translator, Mode::Normal, "", &left, &cfg);
        assert!(matches!(
            resolution.action,
            Some(Action::Motion(MotionKind::Left))
        ));
    }

    #[test]
    fn visual_named_arrow_translates_to_motion() {
        let cfg = Config::default();
        let mut translator = new_translator();
        translator.reset_for_mode(Mode::VisualChar);
        let right =
            KeyEventExt::from_parts(KeyToken::Named(NamedKey::Right), false, Instant::now());
        let resolution = translate_keypress(&mut translator, Mode::VisualChar, "", &right, &cfg);
        assert!(matches!(
            resolution.action,
            Some(Action::Motion(MotionKind::Right))
        ));
    }

    #[test]
    fn cancel_pending_clears_count_prefix() {
        let cfg = Config::default();
        let mut translator = new_translator();
        let digit = KeyEventExt::from_parts(KeyToken::Char('3'), false, Instant::now());
        let pending = translate_keypress(&mut translator, Mode::Normal, "", &digit, &cfg);
        assert!(pending.action.is_none());

        translator.cancel_pending();

        let motion = KeyEventExt::from_parts(KeyToken::Char('l'), false, Instant::now());
        let resolved = translate_keypress(&mut translator, Mode::Normal, "", &motion, &cfg);
        assert!(matches!(
            resolved.action,
            Some(Action::Motion(MotionKind::Right))
        ));
    }

    #[test]
    fn reset_for_insert_clears_register_prefix() {
        let cfg = Config::default();
        let mut translator = new_translator();
        let quote = KeyEventExt::from_parts(KeyToken::Char('"'), false, Instant::now());
        let reg = KeyEventExt::from_parts(KeyToken::Char('b'), false, Instant::now());
        let _ = translate_keypress(&mut translator, Mode::Normal, "", &quote, &cfg);
        let _ = translate_keypress(&mut translator, Mode::Normal, "", &reg, &cfg);

        translator.reset_for_mode(Mode::Insert);
        translator.reset_for_mode(Mode::Normal);

        let paste = KeyEventExt::from_parts(KeyToken::Char('p'), false, Instant::now());
        let resolved = translate_keypress(&mut translator, Mode::Normal, "", &paste, &cfg);
        match resolved.action {
            Some(Action::PasteAfter { register, .. }) => assert!(
                register.is_none(),
                "expected register prefix to clear when entering insert"
            ),
            other => panic!("expected paste action, got {:?}", other),
        }
    }

    // Removed: colon_variant_translation test (Refactor R2 Step 8) – KeyCode::Colon eliminated; ':' represented solely via KeyCode::Char(':').
}
